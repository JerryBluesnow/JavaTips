# 右值 左值

## 为什么引入右值 ?
```
右值引用是C++11中最重要的新特性之一，它解决了C++中大量的历史遗留问题，使C++标准库的实现在多种场景下消除了不必要的额外开销（如std::vector, std::string)，也使得另外一些标准库（如std::unique_ptr, std::function）成为可能。即使你并不直接使用右值引用，也可以通过标准库，间接从这一新特性中受益。为了更好的理解标准库结合右值引用带来的优化，我们有必要了解一下右值引用的重大意义。
右值引用的意义通常解释为两大作用：移动语义和完美转发。本文主要讨论移动语义。

移动语义

移动语义，简单来说解决的是各种情形下对象的资源所有权转移的问题。而在C++11之前，移动语义的缺失是C++饱受诟病的问题之一。
举个栗子。
问题一：如何将大象放入冰箱？
答案是众所周知的。首先你需要有一台特殊的冰箱，这台冰箱是为了装下大象而制造的。你打开冰箱门，将大象放入冰箱，然后关上冰箱门。
问题二：如何将大象从一台冰箱转移到另一台冰箱？
普通解答：打开冰箱门，取出大象，关上冰箱门，打开另一台冰箱门，放进大象，关上冰箱门。
2B解答：在第二个冰箱中启动量子复制系统，克隆一只完全相同的大象，然后启动高能激光将第一个冰箱内的大象气化消失。
等等，这个2B解答听起来很耳熟，这不就是C++中要移动一个对象时所做的事情吗？
“移动”，这是一个三岁小孩都明白的概念。将大象（资源）从一台冰箱（对象）移动到另一台冰箱，这个行为是如此自然，没有任何人会采用先复制大象，再销毁大象这样匪夷所思的方法。C++通过拷贝构造函数和拷贝赋值操作符为类设计了拷贝/复制的概念，但为了实现对资源的移动操作，调用者必须使用先复制、再析构的方式。否则，就需要自己实现移动资源的接口。
为了实现移动语义，首先需要解决的问题是，如何标识对象的资源是可以被移动的呢？这种机制必须以一种最低开销的方式实现，并且对所有的类都有效。C++的设计者们注意到，大多数情况下，右值所包含的对象都是可以安全的被移动的。
右值（相对应的还有左值）是从C语言设计时就有的概念，但因为其如此基础，也是一个最常被忽略的概念。不严格的来说，左值对应变量的存储位置，而右值对应变量的值本身。C++中右值可以被赋值给左值或者绑定到引用。类的右值是一个临时对象，如果没有被绑定到引用，在表达式结束时就会被废弃。于是我们可以在右值被废弃之前，移走它的资源进行废物利用，从而避免无意义的复制。被移走资源的右值在废弃时已经成为空壳，析构的开销也会降低。
右值中的数据可以被安全移走这一特性使得右值被用来表达移动语义。以同类型的右值构造对象时，需要以引用形式传入参数。右值引用顾名思义专门用来引用右值，左值引用和右值引用可以被分别重载，这样确保左值和右值分别调用到拷贝和移动的两种语义实现。对于左值，如果我们明确放弃对其资源的所有权，则可以通过std::move()来将其转为右值引用。std::move()实际上是static_cast<T&&>()的简单封装。
```

- 右值引用顾名思义专门用来引用右值，左值引用和右值引用可以被分别重载，这样确保左值和右值分别调用到拷贝和移动的两种语义实现
- 对于左值，如果我们明确放弃对其资源的所有权，则可以通过std::move()来将其转为右值引用。std::move()实际上是static_cast<T&&>()的简单封装
- 左值对应变量的存储位置，而右值对应变量的值本身
- C++中右值可以被赋值给左值或者绑定到引用
- 类的右值是一个临时对象，如果没有被绑定到引用，在表达式结束时就会被废弃

## c++11为什么要引入右值引用

```cpp
本文适合对c++11刚入门的小伙伴阅读。

本文加深对左值引用、右值引用、左值右值的理解。

首先要理解一下将亡值：将亡值就是在这一行结束之后该值将被析构。最典型的将亡值就是匿名对象，如:Test()。

c++11之前，有一些让人们蛋疼的地方。
需求1：需要转递引用来提高效率，那么我们函数定义是这样的void foo(Test &t){...}。

需求2：现在我们想这样调用函数，foo(Test())。what？编译不过。稍微解释一下，将引用绑定到一个匿名对象，完全没有意义，因为它可能很快就不在了。访问一个不在的对象，是多么恐怖的事情。

我们又想出了其他的办法，重载函数void foo(Test t){...}。what？还编译不过。因为这样重载又二义性，编译器不知道你到底要调用哪个。

最后没辙了，我们只能放大招了，void foo(const Test& t){...}只能这样了。const不是只读的意思吗，怎么还可以这样用。对的const干的活比较多，const Test& t{Test()};这种用法就退化回const Test t{Test()};,这两种写法都会创建一个新的对象，所以const干了一个不属于它的活，这样即保障了传引用的高效又可以传入匿名对象。

需求3：但是我们又需要改变它的值，那好吧，我们只能用const_cast<Test&>(t)强转后来改变他的值。

c++11引入了右值引用来帮助const分担工作。
现在完全可以用void foo(Test&& t)和void foo(Test& t)两个函数来区分传入值是否是将亡值，并且可以重载，无二义性。

注意下面情况：

#include <iostream>
using namespace std;


class Test {
public:
    Test() : x(0) {cout << "构造函数 this = " << this << endl;}
    Test(int x) : x(x) {cout << "构造函数 this = " << this << endl;}
    Test(const Test& another) : x(another.x) {cout << "拷贝构造 this = " << this << " from " << &another << endl;}
    Test(const Test&& another) noexcept : x(another.x) {cout << "移动构造 this = " << this << " from " << &another << endl;}
    ~Test() {cout << "析构函数 this = " << this << endl;}

    int x;
};

ostream& operator<<(ostream& out, const Test& t) {
    out << "&t = " << &t << ", x = " << t.x;
    return out;
}

class Aa {
public:
    Aa(const Test& t) : t(t) { cout << t << endl; cout << this->t << endl;}
    //Aa(const Test&& t) = delete; //这行就可以禁止将亡值来赋值，使编译时报错。
    void foo() {cout << t << endl;}

private:
    const Test &t;
};

int main()
{
    Aa a{Test()};
    a.foo();
    return 0;
}

输出：

构造函数 this = 0x61fe0c
&t = 0x61fe0c, x = 0
&t = 0x61fe0c, x = 0
析构函数 this = 0x61fe0c
&t = 0x61fe0c, x = 0

解释：

第一步：入参const Test& t{Test()};产生了一个临时的匿名只读对象，还是将亡值。

第二步：初始化列表t(t)相当于将刚刚产生的匿名对象，赋值给成员对象&t。

第三步：构造函数结束，匿名对象析构，之后再使用Aa时很危险的。

将移动构造函数显视删除，可以避免这一点。

移动构造函数当然不只是这一点功能，它主要是在stl中和std::move配合提高效率。

左值引用和右值引用的区别
左值引用是起别名，如果这个对象已经析构，那么这个别名也应该一起失效。言外之意就是左值引用一定要保证它的生命周期小于等于它被引用的对象。

当将亡值出现的时候，左值引用表示无能为力，所以右值引用出现了。

右值引用也可以看作起名，只是它起名的对象是一个将亡值。然后延续这个将亡值的生命，直到这个的右值的生命也结束了。

除了入参时可以用到右值引用外，其他右值引用都显得多余。

比如Test&& t{Test()};它和Test t{Test()}是一样的，甚至可以这样Test&& t{}它们都只一个普通对象，只调用一次构造函数。

总结
左值引用只能起别名，但不能给匿名对象起名。

右值引用其实就是给匿名（天生匿名或者通过std::move将名字失效，这样的对象即将被析构）对象重新起名字。

我们一直所说的将亡值其实就是所谓的右值，其它有名字的都是左值，左值引用与左值配合，右值引用与右值配合。
————————————————
版权声明：本文为CSDN博主「waxtear」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/waxtear/article/details/104199314
```


